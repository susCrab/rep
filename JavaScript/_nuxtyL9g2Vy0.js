import{f as a,V as e,E as t}from"./B5Cna7aG.js";import{l as s,b as r,j as n,t as o,al as i,Q as l,c,y as d,u,a as y,g as f}from"./CfmBXBX3.js";const p=a=>"defer"===a||!1===a;function _(...s){var _;const v="string"==typeof s[s.length-1]?s.pop():void 0;"string"!=typeof s[0]&&s.unshift(v);let[m,D,g={}]=s;if("string"!=typeof m)throw new TypeError("[nuxt] [asyncData] key must be a string.");if("function"!=typeof D)throw new TypeError("[nuxt] [asyncData] handler must be a function.");const h=a(),P=D;g.server=g.server??!0,g.default=g.default??(()=>e.value),g.getCachedData=g.getCachedData??(()=>h.isHydrating?h.payload.data[m]:h.static.data[m]),g.lazy=g.lazy??!1,g.immediate=g.immediate??!0,g.deep=g.deep??e.deep,g.dedupe=g.dedupe??"cancel";const b=g.getCachedData(m,h),w=null!=b;if(!h._asyncData[m]||!g.immediate){(_=h.payload._errors)[m]??(_[m]=e.errorValue);const a=g.deep?r:n;h._asyncData[m]={data:a(w?b:g.default()),pending:r(!w),error:o(h.payload._errors,m),status:r("idle"),_default:g.default}}const x={...h._asyncData[m]};delete x._default,x.refresh=x.execute=(a={})=>{if(h._asyncDataPromises[m]){if(p(a.dedupe??g.dedupe))return h._asyncDataPromises[m];h._asyncDataPromises[m].cancelled=!0}if(a._initial||h.isHydrating&&!1!==a._initial){const e=a._initial?b:g.getCachedData(m,h);if(null!=e)return Promise.resolve(e)}x.pending.value=!0,x.status.value="pending";const s=new Promise(((a,e)=>{try{a(P(h))}catch(t){e(t)}})).then((async a=>{if(s.cancelled)return h._asyncDataPromises[m];let t=a;g.transform&&(t=await g.transform(a)),g.pick&&(t=function(a,e){const t={};for(const s of e)t[s]=a[s];return t}(t,g.pick)),h.payload.data[m]=t,x.data.value=t,x.error.value=e.errorValue,x.status.value="success"})).catch((a=>{if(s.cancelled)return h._asyncDataPromises[m];x.error.value=t(a),x.data.value=u(g.default()),x.status.value="error"})).finally((()=>{s.cancelled||(x.pending.value=!1,delete h._asyncDataPromises[m])}));return h._asyncDataPromises[m]=s,h._asyncDataPromises[m]},x.clear=()=>function(a,t){t in a.payload.data&&(a.payload.data[t]=void 0);t in a.payload._errors&&(a.payload._errors[t]=e.errorValue);a._asyncData[t]&&(a._asyncData[t].data.value=void 0,a._asyncData[t].error.value=e.errorValue,a._asyncData[t].pending.value=!1,a._asyncData[t].status.value="idle");t in a._asyncDataPromises&&(a._asyncDataPromises[t]&&(a._asyncDataPromises[t].cancelled=!0),a._asyncDataPromises[t]=void 0)}(h,m);const C=()=>x.refresh({_initial:!0}),O=!1!==g.server&&h.payload.serverRendered;{const a=y();if(a&&!a._nuxtOnBeforeMountCbs){a._nuxtOnBeforeMountCbs=[];const e=a._nuxtOnBeforeMountCbs;i((()=>{e.forEach((a=>{a()})),e.splice(0,e.length)})),l((()=>e.splice(0,e.length)))}O&&h.isHydrating&&(x.error.value||null!=b)?(x.pending.value=!1,x.status.value=x.error.value?"error":"success"):a&&(h.payload.serverRendered&&h.isHydrating||g.lazy)&&g.immediate?a._nuxtOnBeforeMountCbs.push(C):g.immediate&&C();const e=f();if(g.watch){const a=c(g.watch,(()=>x.refresh()));e&&d(a)}const t=h.hook("app:data:refresh",(async a=>{a&&!a.includes(m)||await x.refresh()}));e&&d(t)}const V=Promise.resolve(h._asyncDataPromises[m]).then((()=>x));return Object.assign(V,x),V}function v(...a){const e="string"==typeof a[a.length-1]?a.pop():void 0;"string"!=typeof a[0]&&a.unshift(e);const[t,s,r={}]=a;return _(t,s,{...r,lazy:!0},null)}function m(t){const r=a();return t in r.payload.data||(r.payload.data[t]=e.value),{data:s({get(){var a;return(null==(a=r._asyncData[t])?void 0:a.data.value)??r.payload.data[t]},set(a){r._asyncData[t]?r._asyncData[t].data.value=a:r.payload.data[t]=a}})}}export{m as a,v as b,_ as u};